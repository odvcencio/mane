// Code generated by ts2go batch. DO NOT EDIT.

package grammars

func init() {
	Register(LangEntry{
		Name:           "kotlin",
		Extensions:     []string{".kt", ".kts"},
		Language:       KotlinLanguage,
		HighlightQuery: kotlinHighlightQuery,
	})
}

const kotlinHighlightQuery = ";; Based on the nvim-treesitter highlighting, which is under the Apache license.\n;; See https://github.com/nvim-treesitter/nvim-treesitter/blob/f8ab59861eed4a1c168505e3433462ed800f2bae/queries/kotlin/highlights.scm\n;;\n;; The only difference in this file is that queries using #lua-match?\n;; have been removed.\n\n;;; Identifiers\n\n(simple_identifier) @variable\n\n; `it` keyword inside lambdas\n; FIXME: This will highlight the keyword outside of lambdas since tree-sitter\n;        does not allow us to check for arbitrary nestation\n((simple_identifier) @variable.builtin\n(#eq? @variable.builtin \"it\"))\n\n; `field` keyword inside property getter/setter\n; FIXME: This will highlight the keyword outside of getters and setters\n;        since tree-sitter does not allow us to check for arbitrary nestation\n((simple_identifier) @variable.builtin\n(#eq? @variable.builtin \"field\"))\n\n; `this` this keyword inside classes\n(this_expression) @variable.builtin\n\n; `super` keyword inside classes\n(super_expression) @variable.builtin\n\n(class_parameter\n\t(simple_identifier) @property)\n\n(class_body\n\t(property_declaration\n\t\t(variable_declaration\n\t\t\t(simple_identifier) @property)))\n\n; id_1.id_2.id_3: `id_2` and `id_3` are assumed as object properties\n(_\n\t(navigation_suffix\n\t\t(simple_identifier) @property))\n\n(enum_entry\n\t(simple_identifier) @constant)\n\n(type_identifier) @type\n\n((type_identifier) @type.builtin\n\t(#any-of? @type.builtin\n\t\t\"Byte\"\n\t\t\"Short\"\n\t\t\"Int\"\n\t\t\"Long\"\n\t\t\"UByte\"\n\t\t\"UShort\"\n\t\t\"UInt\"\n\t\t\"ULong\"\n\t\t\"Float\"\n\t\t\"Double\"\n\t\t\"Boolean\"\n\t\t\"Char\"\n\t\t\"String\"\n\t\t\"Array\"\n\t\t\"ByteArray\"\n\t\t\"ShortArray\"\n\t\t\"IntArray\"\n\t\t\"LongArray\"\n\t\t\"UByteArray\"\n\t\t\"UShortArray\"\n\t\t\"UIntArray\"\n\t\t\"ULongArray\"\n\t\t\"FloatArray\"\n\t\t\"DoubleArray\"\n\t\t\"BooleanArray\"\n\t\t\"CharArray\"\n\t\t\"Map\"\n\t\t\"Set\"\n\t\t\"List\"\n\t\t\"EmptyMap\"\n\t\t\"EmptySet\"\n\t\t\"EmptyList\"\n\t\t\"MutableMap\"\n\t\t\"MutableSet\"\n\t\t\"MutableList\"\n))\n\n(package_header\n\t. (identifier)) @namespace\n\n(import_header\n\t\"import\" @include)\n\n\n; TODO: Seperate labeled returns/breaks/continue/super/this\n;       Must be implemented in the parser first\n(label) @label\n\n;;; Function definitions\n\n(function_declaration\n\t. (simple_identifier) @function)\n\n(getter\n\t(\"get\") @function.builtin)\n(setter\n\t(\"set\") @function.builtin)\n\n(primary_constructor) @constructor\n(secondary_constructor\n\t(\"constructor\") @constructor)\n\n(constructor_invocation\n\t(user_type\n\t\t(type_identifier) @constructor))\n\n(anonymous_initializer\n\t(\"init\") @constructor)\n\n(parameter\n\t(simple_identifier) @parameter)\n\n(parameter_with_optional_type\n\t(simple_identifier) @parameter)\n\n; lambda parameters\n(lambda_literal\n\t(lambda_parameters\n\t\t(variable_declaration\n\t\t\t(simple_identifier) @parameter)))\n\n;;; Function calls\n\n; function()\n(call_expression\n\t. (simple_identifier) @function)\n\n; object.function() or object.property.function()\n(call_expression\n\t(navigation_expression\n\t\t(navigation_suffix\n\t\t\t(simple_identifier) @function) . ))\n\n(call_expression\n\t. (simple_identifier) @function.builtin\n    (#any-of? @function.builtin\n\t\t\"arrayOf\"\n\t\t\"arrayOfNulls\"\n\t\t\"byteArrayOf\"\n\t\t\"shortArrayOf\"\n\t\t\"intArrayOf\"\n\t\t\"longArrayOf\"\n\t\t\"ubyteArrayOf\"\n\t\t\"ushortArrayOf\"\n\t\t\"uintArrayOf\"\n\t\t\"ulongArrayOf\"\n\t\t\"floatArrayOf\"\n\t\t\"doubleArrayOf\"\n\t\t\"booleanArrayOf\"\n\t\t\"charArrayOf\"\n\t\t\"emptyArray\"\n\t\t\"mapOf\"\n\t\t\"setOf\"\n\t\t\"listOf\"\n\t\t\"emptyMap\"\n\t\t\"emptySet\"\n\t\t\"emptyList\"\n\t\t\"mutableMapOf\"\n\t\t\"mutableSetOf\"\n\t\t\"mutableListOf\"\n\t\t\"print\"\n\t\t\"println\"\n\t\t\"error\"\n\t\t\"TODO\"\n\t\t\"run\"\n\t\t\"runCatching\"\n\t\t\"repeat\"\n\t\t\"lazy\"\n\t\t\"lazyOf\"\n\t\t\"enumValues\"\n\t\t\"enumValueOf\"\n\t\t\"assert\"\n\t\t\"check\"\n\t\t\"checkNotNull\"\n\t\t\"require\"\n\t\t\"requireNotNull\"\n\t\t\"with\"\n\t\t\"synchronized\"\n))\n\n;;; Literals\n\n[\n\t(line_comment)\n\t(multiline_comment)\n\t(shebang_line)\n] @comment\n\n(real_literal) @float\n[\n\t(integer_literal)\n\t(long_literal)\n\t(hex_literal)\n\t(bin_literal)\n\t(unsigned_literal)\n] @number\n\n[\n\t(null_literal) ; should be highlighted the same as booleans\n\t(boolean_literal)\n] @boolean\n\n(character_literal) @character\n\n(string_literal) @string\n\n(character_escape_seq) @string.escape\n\n; There are 3 ways to define a regex\n;    - \"[abc]?\".toRegex()\n(call_expression\n\t(navigation_expression\n\t\t((string_literal) @string.regex)\n\t\t(navigation_suffix\n\t\t\t((simple_identifier) @_function\n\t\t\t(#eq? @_function \"toRegex\")))))\n\n;    - Regex(\"[abc]?\")\n(call_expression\n\t((simple_identifier) @_function\n\t(#eq? @_function \"Regex\"))\n\t(call_suffix\n\t\t(value_arguments\n\t\t\t(value_argument\n\t\t\t\t(string_literal) @string.regex))))\n\n;   - Regex.fromLiteral(\"[abc]?\")\n(call_expression\n\t(navigation_expression\n\t\t((simple_identifier) @_class\n\t\t(#eq? @_class \"Regex\"))\n\t\t(navigation_suffix\n\t\t\t((simple_identifier) @_function\n\t\t\t(#eq? @_function \"fromLiteral\"))))\n\t(call_suffix\n\t\t(value_arguments\n\t\t\t(value_argument\n\t\t\t\t(string_literal) @string.regex))))\n\n;;; Keywords\n\n(type_alias \"typealias\" @keyword)\n[\n\t(class_modifier)\n\t(member_modifier)\n\t(function_modifier)\n\t(property_modifier)\n\t(platform_modifier)\n\t(variance_modifier)\n\t(parameter_modifier)\n\t(visibility_modifier)\n\t(reification_modifier)\n\t(inheritance_modifier)\n]@keyword\n\n[\n\t\"val\"\n\t\"var\"\n\t\"enum\"\n\t\"class\"\n\t\"object\"\n\t\"interface\"\n;\t\"typeof\" ; NOTE: It is reserved for future use\n] @keyword\n\n(\"fun\") @keyword.function\n\n(jump_expression) @keyword.return\n\n[\n\t\"if\"\n\t\"else\"\n\t\"when\"\n] @conditional\n\n[\n\t\"for\"\n\t\"do\"\n\t\"while\"\n] @repeat\n\n[\n\t\"try\"\n\t\"catch\"\n\t\"throw\"\n\t\"finally\"\n] @exception\n\n\n(annotation\n\t\"@\" @attribute (use_site_target)? @attribute)\n(annotation\n\t(user_type\n\t\t(type_identifier) @attribute))\n(annotation\n\t(constructor_invocation\n\t\t(user_type\n\t\t\t(type_identifier) @attribute)))\n\n(file_annotation\n\t\"@\" @attribute \"file\" @attribute \":\" @attribute)\n(file_annotation\n\t(user_type\n\t\t(type_identifier) @attribute))\n(file_annotation\n\t(constructor_invocation\n\t\t(user_type\n\t\t\t(type_identifier) @attribute)))\n\n;;; Operators & Punctuation\n\n[\n\t\"!\"\n\t\"!=\"\n\t\"!==\"\n\t\"=\"\n\t\"==\"\n\t\"===\"\n\t\">\"\n\t\">=\"\n\t\"<\"\n\t\"<=\"\n\t\"||\"\n\t\"&&\"\n\t\"+\"\n\t\"++\"\n\t\"+=\"\n\t\"-\"\n\t\"--\"\n\t\"-=\"\n\t\"*\"\n\t\"*=\"\n\t\"/\"\n\t\"/=\"\n\t\"%\"\n\t\"%=\"\n\t\"?.\"\n\t\"?:\"\n\t\"!!\"\n\t\"is\"\n\t\"in\"\n\t\"as\"\n\t\"as?\"\n\t\"..\"\n\t\"..<\"\n\t\"->\"\n] @operator\n\n[\n\t\"(\" \")\"\n\t\"[\" \"]\"\n\t\"{\" \"}\"\n] @punctuation.bracket\n\n[\n\t\".\"\n\t\",\"\n\t\";\"\n\t\":\"\n\t\"::\"\n] @punctuation.delimiter\n\n; NOTE: `interpolated_identifier`s can be highlighted in any way\n(string_literal\n\t\"$\" @punctuation.special\n\t(interpolated_identifier) @none)\n(string_literal\n\t\"${\" @punctuation.special\n\t(interpolated_expression) @none\n\t\"}\" @punctuation.special)\n"
