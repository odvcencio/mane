package main

import (
	"fmt"
	"strings"
	"unicode"
)

// GenerateGo produces a Go source file that creates a *gotreesitter.Language
// populated with all extracted grammar data.
func GenerateGo(g *ExtractedGrammar, pkg string) string {
	var buf strings.Builder

	buf.WriteString("// Code generated by ts2go. DO NOT EDIT.\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkg)
	buf.WriteString("import \"github.com/odvcencio/mane/gotreesitter\"\n\n")

	funcName := languageFuncName(g.Name)
	fmt.Fprintf(&buf, "// %s returns the %s language definition.\n", funcName, g.Name)
	fmt.Fprintf(&buf, "func %s() *gotreesitter.Language {\n", funcName)
	buf.WriteString("\treturn &gotreesitter.Language{\n")

	// Name
	fmt.Fprintf(&buf, "\t\tName: %q,\n", g.Name)

	// Counts
	fmt.Fprintf(&buf, "\t\tSymbolCount:        %d,\n", g.SymbolCount)
	fmt.Fprintf(&buf, "\t\tTokenCount:         %d,\n", g.TokenCount)
	fmt.Fprintf(&buf, "\t\tExternalTokenCount: %d,\n", g.ExternalTokenCount)
	fmt.Fprintf(&buf, "\t\tStateCount:         %d,\n", g.StateCount)
	fmt.Fprintf(&buf, "\t\tLargeStateCount:    %d,\n", g.LargeStateCount)
	fmt.Fprintf(&buf, "\t\tFieldCount:         %d,\n", g.FieldCount)
	fmt.Fprintf(&buf, "\t\tProductionIDCount:  %d,\n", g.ProductionIDCount)

	// Tree-sitter grammars always start at state 1 (state 0 is error recovery).
	buf.WriteString("\t\tInitialState:       1,\n")

	// Symbol names
	writeStringSlice(&buf, "SymbolNames", g.SymbolNames)

	// Symbol metadata
	writeSymbolMetadata(&buf, g.SymbolMetadata, g.SymbolNames)

	// Field names
	if len(g.FieldNames) > 0 {
		writeStringSlice(&buf, "FieldNames", g.FieldNames)
	}

	// Field maps
	if len(g.FieldMapSlices) > 0 {
		writeFieldMapSlices(&buf, g.FieldMapSlices)
	}
	if len(g.FieldMapEntries) > 0 {
		writeFieldMapEntries(&buf, g.FieldMapEntries)
	}

	// Parse table (dense, for large states)
	if len(g.ParseTable) > 0 {
		writeParseTable(&buf, g.ParseTable)
	}

	// Small parse table (compressed)
	if len(g.SmallParseTable) > 0 {
		writeUint16Slice(&buf, "SmallParseTable", g.SmallParseTable)
	}
	if len(g.SmallParseTableMap) > 0 {
		writeUint32Slice(&buf, "SmallParseTableMap", g.SmallParseTableMap)
	}

	// Parse actions
	writeParseActions(&buf, g.ParseActions)

	// Lex modes
	writeLexModes(&buf, g.LexModes)

	if len(g.ExternalSymbols) > 0 {
		writeExternalSymbols(&buf, g.ExternalSymbols)
	}

	buf.WriteString("\t}\n}\n")
	return buf.String()
}

func languageFuncName(name string) string {
	id := toExportedIdentifier(name)
	if id == "" {
		id = "Lang"
	}
	if unicode.IsDigit([]rune(id)[0]) {
		id = "Lang" + id
	}
	return id + "Language"
}

func toExportedIdentifier(s string) string {
	var parts []string
	var cur []rune
	flush := func() {
		if len(cur) == 0 {
			return
		}
		r := cur
		r[0] = unicode.ToUpper(r[0])
		parts = append(parts, string(r))
		cur = nil
	}

	for _, ch := range s {
		if unicode.IsLetter(ch) || unicode.IsDigit(ch) {
			cur = append(cur, ch)
			continue
		}
		flush()
	}
	flush()
	return strings.Join(parts, "")
}

func writeStringSlice(buf *strings.Builder, name string, vals []string) {
	fmt.Fprintf(buf, "\t\t%s: []string{\n", name)
	for _, v := range vals {
		fmt.Fprintf(buf, "\t\t\t%q,\n", v)
	}
	buf.WriteString("\t\t},\n")
}

func writeFieldMapSlices(buf *strings.Builder, slices [][2]uint16) {
	buf.WriteString("\t\tFieldMapSlices: [][2]uint16{\n")
	for _, s := range slices {
		fmt.Fprintf(buf, "\t\t\t{%d, %d},\n", s[0], s[1])
	}
	buf.WriteString("\t\t},\n")
}

func writeFieldMapEntries(buf *strings.Builder, entries []FieldMapEntry) {
	buf.WriteString("\t\tFieldMapEntries: []gotreesitter.FieldMapEntry{\n")
	for _, e := range entries {
		fmt.Fprintf(buf, "\t\t\t{FieldID: gotreesitter.FieldID(%d), ChildIndex: uint8(%d), Inherited: %t},\n",
			e.FieldID, e.ChildIndex, e.Inherited)
	}
	buf.WriteString("\t\t},\n")
}

func writeSymbolMetadata(buf *strings.Builder, meta []SymbolMeta, names []string) {
	buf.WriteString("\t\tSymbolMetadata: []gotreesitter.SymbolMetadata{\n")
	for i, m := range meta {
		name := ""
		if i < len(names) {
			name = names[i]
		}
		fmt.Fprintf(buf, "\t\t\t{Name: %q, Visible: %t, Named: %t, Supertype: %t},\n",
			name, m.Visible, m.Named, m.Supertype)
	}
	buf.WriteString("\t\t},\n")
}

func writeParseTable(buf *strings.Builder, table [][]uint16) {
	buf.WriteString("\t\tParseTable: [][]uint16{\n")
	for _, row := range table {
		buf.WriteString("\t\t\t{")
		for j, v := range row {
			if j > 0 {
				buf.WriteString(", ")
			}
			fmt.Fprintf(buf, "%d", v)
		}
		buf.WriteString("},\n")
	}
	buf.WriteString("\t\t},\n")
}

func writeUint16Slice(buf *strings.Builder, name string, vals []uint16) {
	fmt.Fprintf(buf, "\t\t%s: []uint16{\n\t\t\t", name)
	for i, v := range vals {
		if i > 0 && i%20 == 0 {
			buf.WriteString("\n\t\t\t")
		}
		fmt.Fprintf(buf, "%d, ", v)
	}
	buf.WriteString("\n\t\t},\n")
}

func writeUint32Slice(buf *strings.Builder, name string, vals []uint32) {
	fmt.Fprintf(buf, "\t\t%s: []uint32{\n\t\t\t", name)
	for i, v := range vals {
		if i > 0 && i%20 == 0 {
			buf.WriteString("\n\t\t\t")
		}
		fmt.Fprintf(buf, "%d, ", v)
	}
	buf.WriteString("\n\t\t},\n")
}

func writeParseActions(buf *strings.Builder, groups []ActionGroup) {
	// The parse table and small parse table reference entries by their C array
	// index. In C, each header entry is followed by N action entries inline.
	// We need to pad the Go slice so that Go index == C index for each header.
	//
	// Find the max C index to determine the slice size.
	maxIdx := 0
	for _, ag := range groups {
		if ag.Index > maxIdx {
			maxIdx = ag.Index
		}
	}

	buf.WriteString("\t\tParseActions: []gotreesitter.ParseActionEntry{\n")

	// Build a map from C index to group.
	groupMap := make(map[int]*ActionGroup, len(groups))
	for i := range groups {
		groupMap[groups[i].Index] = &groups[i]
	}

	for i := 0; i <= maxIdx; i++ {
		ag, ok := groupMap[i]
		if !ok {
			// Padding entry â€” this C index is an action slot or unused.
			buf.WriteString("\t\t\t{},\n")
			continue
		}
		fmt.Fprintf(buf, "\t\t\t{Reusable: %t, Actions: []gotreesitter.ParseAction{", ag.Reusable)
		for j, a := range ag.Actions {
			if j > 0 {
				buf.WriteString(", ")
			}
			switch a.Type {
			case "shift":
				fmt.Fprintf(buf, "{Type: gotreesitter.ParseActionShift, State: gotreesitter.StateID(%d), Extra: %t, Repetition: %t}",
					a.State, a.Extra, a.Repetition)
			case "reduce":
				fmt.Fprintf(buf, "{Type: gotreesitter.ParseActionReduce, Symbol: gotreesitter.Symbol(%d), ChildCount: %d, DynamicPrecedence: %d, ProductionID: %d}",
					a.Symbol, a.ChildCount, a.Precedence, a.ProductionID)
			case "accept":
				buf.WriteString("{Type: gotreesitter.ParseActionAccept}")
			case "recover":
				buf.WriteString("{Type: gotreesitter.ParseActionRecover}")
			}
		}
		buf.WriteString("}},\n")
	}
	buf.WriteString("\t\t},\n")
}

func writeLexModes(buf *strings.Builder, modes []LexModeEntry) {
	buf.WriteString("\t\tLexModes: []gotreesitter.LexMode{\n")
	for _, m := range modes {
		fmt.Fprintf(buf, "\t\t\t{LexState: %d, ExternalLexState: %d},\n", m.LexState, m.ExternalLexState)
	}
	buf.WriteString("\t\t},\n")
}

func writeExternalSymbols(buf *strings.Builder, symbols []uint16) {
	buf.WriteString("\t\tExternalSymbols: []gotreesitter.Symbol{\n")
	for _, s := range symbols {
		fmt.Fprintf(buf, "\t\t\tgotreesitter.Symbol(%d),\n", s)
	}
	buf.WriteString("\t\t},\n")
}
