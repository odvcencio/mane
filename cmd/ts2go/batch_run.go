package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// RunBatchManifest clones each grammar repo in the manifest, extracts parser
// tables, and writes generated Go grammar files to outDir.
func RunBatchManifest(manifestPath, outDir, pkg string) error {
	entries, err := ParseManifest(manifestPath)
	if err != nil {
		return fmt.Errorf("parse manifest: %w", err)
	}
	if len(entries) == 0 {
		return fmt.Errorf("manifest is empty: %s", manifestPath)
	}

	if err := os.MkdirAll(outDir, 0755); err != nil {
		return fmt.Errorf("mkdir outdir: %w", err)
	}

	tmpRoot, err := os.MkdirTemp("", "ts2go-batch-*")
	if err != nil {
		return fmt.Errorf("mktemp: %w", err)
	}
	defer os.RemoveAll(tmpRoot)

	for _, entry := range entries {
		repoDir := filepath.Join(tmpRoot, safeFileBase(entry.Name))
		if err := cloneRepo(entry.RepoURL, repoDir); err != nil {
			return fmt.Errorf("%s: clone: %w", entry.Name, err)
		}

		parserPath := filepath.Join(repoDir, entry.Subdir, "parser.c")
		if _, err := os.Stat(parserPath); err != nil {
			detected, derr := findParserC(repoDir)
			if derr != nil {
				return fmt.Errorf("%s: parser.c not found under %s", entry.Name, repoDir)
			}
			parserPath = detected
		}
		source, err := os.ReadFile(parserPath)
		if err != nil {
			return fmt.Errorf("%s: read %s: %w", entry.Name, parserPath, err)
		}

		grammar, err := ExtractGrammar(string(source))
		if err != nil {
			return fmt.Errorf("%s: extract: %w", entry.Name, err)
		}
		grammar.Name = entry.Name

		code := GenerateGo(grammar, pkg)
		outFile := filepath.Join(outDir, safeFileBase(entry.Name)+"_grammar.go")
		if err := os.WriteFile(outFile, []byte(code), 0644); err != nil {
			return fmt.Errorf("%s: write %s: %w", entry.Name, outFile, err)
		}

		if q, ok := loadHighlightQuery(repoDir); ok {
			if err := writeRegisterStub(outDir, entry, q); err != nil {
				return fmt.Errorf("%s: write register stub: %w", entry.Name, err)
			}
		}

		fmt.Printf("generated %s (%d states, %d symbols)\n", outFile, grammar.StateCount, grammar.SymbolCount)
	}

	return nil
}

func cloneRepo(repoURL, dest string) error {
	cmd := exec.Command("git", "clone", "--depth=1", repoURL, dest)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%v: %s", err, strings.TrimSpace(string(out)))
	}
	return nil
}

func loadHighlightQuery(repoDir string) (string, bool) {
	candidates := []string{
		filepath.Join(repoDir, "queries", "highlights.scm"),
		filepath.Join(repoDir, "queries", "highlight.scm"),
	}
	for _, p := range candidates {
		b, err := os.ReadFile(p)
		if err == nil {
			return string(b), true
		}
	}
	return "", false
}

func writeRegisterStub(outDir string, entry ManifestEntry, highlightQuery string) error {
	nameIdent := languageRegisterIdentifier(entry.Name)
	funcName := languageFuncName(entry.Name)

	var extList strings.Builder
	for i, ext := range entry.Extensions {
		if i > 0 {
			extList.WriteString(", ")
		}
		extList.WriteString(fmt.Sprintf("%q", ext))
	}
	extExpr := "nil"
	if extList.Len() > 0 {
		extExpr = "[]string{" + extList.String() + "}"
	}

	code := fmt.Sprintf(`// Code generated by ts2go batch. DO NOT EDIT.

package grammars

func init() {
	Register(LangEntry{
		Name:           %q,
		Extensions:     %s,
		Language:       %s,
		HighlightQuery: %sHighlightQuery,
		TokenSourceFactory: defaultTokenSourceFactory(%q),
	})
}

const %sHighlightQuery = %q
`, entry.Name, extExpr, funcName, nameIdent, entry.Name, nameIdent, highlightQuery)

	outFile := filepath.Join(outDir, safeFileBase(entry.Name)+"_register.go")
	return os.WriteFile(outFile, []byte(code), 0644)
}

func safeFileBase(s string) string {
	s = strings.TrimSpace(strings.ToLower(s))
	if s == "" {
		return "lang"
	}
	var b strings.Builder
	for _, r := range s {
		switch {
		case r >= 'a' && r <= 'z':
			b.WriteRune(r)
		case r >= '0' && r <= '9':
			b.WriteRune(r)
		default:
			b.WriteRune('_')
		}
	}
	return strings.Trim(b.String(), "_")
}

func languageRegisterIdentifier(name string) string {
	id := toExportedIdentifier(name)
	if id == "" {
		id = "Lang"
	}
	return strings.ToLower(id[:1]) + id[1:]
}

func findParserC(repoDir string) (string, error) {
	var candidates []string
	err := filepath.WalkDir(repoDir, func(path string, d os.DirEntry, err error) error {
		if err != nil {
			return nil
		}
		if d.IsDir() {
			base := filepath.Base(path)
			if base == ".git" || base == "node_modules" {
				return filepath.SkipDir
			}
			return nil
		}
		if d.Name() == "parser.c" {
			candidates = append(candidates, path)
		}
		return nil
	})
	if err != nil {
		return "", err
	}
	if len(candidates) == 0 {
		return "", fmt.Errorf("parser.c not found")
	}
	for _, c := range candidates {
		if strings.Contains(c, string(filepath.Separator)+"src"+string(filepath.Separator)+"parser.c") {
			return c, nil
		}
	}
	return candidates[0], nil
}
